---
title: 前端面试题2022
display: home
lang: zh
description: 面试题
image: https://picsum.photos/536/354?random&date=2022-03-02
date: 2022-03-02
vssue-title: vuepress-plugin-img-lazy
categories:
  - 面试题
  - 前端
---

# CSS HTML

#### 盒子模型

标准盒子模型(box-sizing: content-box)：margin, border, padding, content  
IE盒子模型(box-sizing: border-box)：margin, content(padding, border, content) 

<!-- more -->

#### CSS常见可继承属性

1. 文字系列: font, font-family, font-size, font-weight, font-style
2. 文本系列: text-indent, text-align, text-shadow, line-height, word-spacing, letter-spacing, text-transform, direction, color,
3. 元素可见性: visibility
4. 表格布局属性: caption-side, border-collapse, empty-cells
5. 列表属性: list-style-type, list-style-image, list-style-position, list-style

#### CSS不能继承的属性

1. display
2. 文本属性: vertical-align, text-decoration
3. 盒子模型属性: 宽度, 高度, 内外边距, 边框
4. 背景属性: 背景图片, 颜色, 位置
5. 定位属性: 浮动, 清除浮动, 定位position
6. a标签的字体颜色不能被继承
7. h1到h6的字体大小也是不能被继承的

#### HTML和HTML5的区别

三个主要区别
1. 文档声明区别
   HTML: 超文本标记语言，纯文本语言  
   HTML5: 文档声明HTML5方便书写 
   ``` html
    <!DOCTYPE html>
   ```
2. 结构语义区别
   HTML5添加了许多语义化标签:  
   ``` html
    <header>
    <nav>
    <section>
    <article>
    <aside>
    <figcaption>
    <figure>
    <footer>
   ```
3. 绘图区别
   HTML: 指可伸缩矢量图形，用于定义网络的基于矢量的图形  
   HTML5: canvas使用脚本在网页上绘制图形，可以控制画布上每一个元素

#### cookie、sessionStorage和localStorage的区别

1. cookie: 本身用户客户端和服务端通信，但是有本地储存的功能，通过document.cookie来获取和修改,如果设置了过期时间，那么在时间到期时会自动消失，如果没有设置过期时间，那么cookie是会话级别的，当会话结束cookie就结束了。  
   cookie缺点: 存储量较小，4kb，会伴随着http的请求头传到服务端
2. localStorage: 生命周期是永久的，除非主动删除，否则不会随着浏览器的关闭而删除。
3. sessionStorage: 临时会话，伴随着浏览器窗口的关闭而删除。当浏览器窗口没有关闭，即使刷新页面或者进入同源窗口，数据也纯在。

#### 常见浏览器内核

Trident: IE(被官方废弃)，只能用于windows，不是开源的  
Gecko: Firefox, 开源，可以跨平台  
Webkit: safari以及低版本Chrome浏览器，开源
Prseto: Opera浏览器  
Blink: 现在的Chrome浏览器

#### W3C标准

对结构: 标签小写，标签闭合，标签不能随意嵌套  
对表现和行为: 建议使用外联CSS和js脚本，实现结构与行为分离，结构与表现分离，主要是为了提高页面渲染速度更快的显示页面。  

#### 如何实现浏览器响应式布局

1. 使用媒体查询@media
2. 使用flex布局
3. 使用rem/百分比/vh/vw单位

#### img的title、alt区别

title: 鼠标移动到图片上显示的文字  
alt: 是图片特有的，当图片加载不出来的时候显示，利于浏览器的SEO检索

#### 表单中的readonly和disabled的区别

相同点: 用户都不能改变表中内容  
不同点: 
1. readonly只作用域input和textarea，disabled可以作用于任何元素
2. readonly可以获取到元素焦点，只是不能修改。disabled设置的文本框无法获取到焦点  
3. 如果表单的字段是disabled，则该字段不会发送或者序列化

# 浏览器

#### 浏览器中输入URL到网页显示，发生了什么

1. DNS域名解析
2. tcp三次握手
3. 建立tcp链接后发送http请求
4. 服务端响应请求，返回请求
5. 浏览器解析HTML，并请求HTML中的资源
6. 浏览器对页面渲染

#### 对BFC规范的理解

BFC(Block formatting context)直译为"块级格式化上下文", 它是一个独立的渲染区域。  
当脱离文档流时会产生:  
1. 根元素，HTML是最大的BFC
2. float的值不为none
3. position的值为absolute或者fixed(sticky不会触发BFC，在计算高度时不会计算float元素)

#### 安全性问题

1. XSS攻击: 注入恶意代码  
   - cookie设置为httpOnly
   - 转义页面输入输出内容
2. CSRF : 跨站请求伪造，防护
   - get 不修改数据
   - 不被第三方网站访问到用户的 cookie
   - 设置白名单，不被第三方网站请求
   - 请求校验

# js部分

#### js变量和函数声明提升

js中用var声明的变量会提升至最顶部执行，即可以在声明变量之前使用该变量。函数声明也会提升，并且函数声明优先与变量声明，匿名函数不会提升。  
由ES6的const和let声明的变量不会提升，所以只能在声明后使用变量，因为此声明会造成暂时性死区，产生块作用域。

#### var、let和const的区别

**var**: ES6之前用来声明变量的关键字。声明的变量会提升到作用域的顶端，所以在没有声明变量之前可以使用变量，会返回undefined。可以被重新声明和修改。 
**let**: ES6之后用来声明变量的关键字。声明的变量在编译时执行，不会变量提升，所以不能在声明之前使用。不能被重新声明，但是可以修改值。let是块级作用域，声明的变量只能在该块中使用。

```js
// var 声明
if(true) {
    var a = 'var声明变量'
}
console.log(a) // var声明变量

// let 声明
if(true) {
    let b = 'let声明变量'
}
console.log(b) // b is not defined
```

**const**: ES6之后用来声明常量的关键字。声明的变量编译时执行，与let一样是块级作用域，不会变量提升，不能重新声明，不能重新赋值，所以必须赋初始值。在对象和数组的声明时，可以更新对象的属性。

#### 闭包

外部函数可以访问内部函数的变量，一个函数作为另一个函数的返回值。  

好处: 保存变量，避免被垃圾回收。可以读取内部函数的变量。
坏处: 耗内存，内存泄漏。

#### this

ECMAScript中这样介绍:
> this 关键字执行为当前执行环境的ThisBinding
MDN这样介绍:
> 在绝大多数情况下，函数的调用方式决定了this的值
可以理解为，在JavaScript中，this的调用时决定的，而不是在创建时决定的，this具有运行时绑定的特性。  
执行期上下文三阶段: 创建，执行，回收。  
this的执行是在创建时被确定的。  

#### map和forEach的区别

forEach基础遍历方法，三个参数，当前项，当前项的索引，以及当前遍历的数组。  
map的用法与forEach一样，不同在它返回一个新的数组，所以必须要由返回值，不然就会返回undefined。  

#### 严格模式限制

- 变量必须声明在使用
- 参数不能有同名属性
- 不能使用with语句
- 禁止this指向全局

#### ES6新增

- 变量声明let、const
- 模板字符串
- 箭头函数、函数可以设置默认参数
- 解构赋值
- 展开符
- 数组方法forEach()、map()、filter()、reduce()、some()、every()
- 对象方法Object.is()比较两个值严格相等，例: Object.is(NaN,NaN)，返回true
- 数组创建，Array.from(), 将类数组或者可迭代对象转为数组
- 新的原始数据类型Symbol，通过Symbol('')创建

#### 什么是单线程，和异步什么关系

单线程: 只有一个线程，只能做一件事。  
在js中，单线程意味着所有的任务需要排队。然后当等待时间过长，就会拖延整个程序的执行。浏览器无响应往往就是因为一个脚本执行时间过长导致的。为了解决这个问题，浏览器将任务分为同步和异步。  
**同步**: 在func返回的时候，得到预期的结果，那么这个函数就是同步的。  
**异步**: 在func返回的时候，得不到预期的结果，而是在将来需要通过一些手段才能得到，那么这个函数就是异步的。  

#### 作用域链

作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此可以通过作用域链访问到父级里面的变量和函数。

#### 什么是原型、原型链、继承

- 原型: 所有的函数都有prototype属性(原型)，所有的对象都有_proto_属性。  
- 原型链: 在JavaScript中，每个函数都有一个原型属性prototype指向自身原型，并且由这个函数作为构造函数而创建的对象会有一个_proto_属性指向这个原型，然而函数的原型是一个对象，所以这个对象有一个_proto_指向自己的原型，直到Object的原型，这样就形成原型链。  
- 继承: 
  - 原型链继承，核心: 将Parent的原型指向Child。缺点: 父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变
  
  ```js
    function Parent() {
        this.name = 'fedaily'
    }

    Parent.prototype.getName = function() {
        return this.name;
    }

    function Child() {}

    // 这里也可以直接写出Child.prototype = Parent.prototype
    // 但是这样就不能访问到父类的构造函数的属性了，即this.name
    Child.prototype = new Parent()

    var child = new Child()
    child.getName() // fedaily
    ```
  - 构造函数继承: 修改父类构造函数的this指向，在子类构造函数中执行父类构造函数，同时修改父类构造函数this为子类的this。 缺点: 所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法

  ```js
    function Parent() {
        this.name = ['fedaily']
    }

    function Child() {
        Parent.call(this)
    }

    var child = new Child()
    child.name.push('fe')

    var child2 = new Child() // child2.name === ['fedaily']
  ```
  - ES6提供了Class语法糖，同时提供了extends实现继承。
  ```js
    class Parent {
        constructor() {
            this.name = 'fedaily'
        }

        getName() {
            return this.name
        }
    }

    class Child extends Parent {
        constructor() {
            // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明
            super()
            this.topic = 'fe'
        }
    }

    const child = new Child()
    child.getName() // fedaily
    ```
#### js的垃圾回收机制是怎样的

- **概述**: js中的垃圾回收机制是为了防止内存泄漏，不停的去寻找不在使用的变量，去释放掉它们所指向的内存，js的执行环境会管理代码执行中的内存。
- **变量的声明周期**: 局部变量，存在与函数中，当函数执行完毕后，该变量内存就被释放。全局变量，当浏览窗口被关闭时内存释放。
- **js垃圾回收方式**: 标记清除，引用计数  
    标记清除: 当变量进入执行环境时，垃圾回收器会将这个变量标记，离开环境时再度标记，然后清除。
    引用计数: 每次引用加一，被释放时减一，当这个值的引用次数变成 0 时，就可以将其内存空间回收

# vue

#### 组件通信
1. props / $emit
2. $children / $parent
3. provide / reject
4. ref
5. eventBus
6. vuex
7. localStroage / sessionStroage
8. $attrs / $listeners

#### <keep-alive></keep-alive>的作用是什么

用于需要频繁切换组件缓存，不需要重新渲染页面。

#### 如何获取dom

给dom元素添加ref='name'，然后通过this.$ref.name来获取dom。

#### 为什么用key

便于diff算法识别节点，使页面渲染加快。

#### 分别减速computed和watch的使用场景

- 所有需要计算的属性都可以用computed，多条数据影响一条数据时用computed
- 一条数据影响多条数据时用watch

#### $nextTick的使用

处理Vue中dom的异步更新。在数据更新后，dom渲染之后自动执行的回调函数。

#### vue组件中的data为什么要以函数的形式

以函数返回值的形式出现，保证在使用组件时生成新的data，这样在复用组件时不会造成混乱，各自维护自己的data。单纯使用对象，那么所有组件实例共同拥有一个data。

#### vue双向数据绑定是如何实现的

核心: vue2使用Object.defineProperty(), vue3中使用代理proxy  
通过数据劫持结合订阅发布来实现，做到数据更新视图，视图更新数据。

#### 父组件和子组件的生命周期加载顺序

- 加载渲染过程

> 父beforeCreate => 父created => 父beforeMount => 子beforeCreate => 子created => 子beforeMount => 子mounted => 父mounted

- 子组件更新过程

> 父beforeUpdate => 子beforeUpdate => 子updated => 父updated

- 父组件更新

> 父beforeUpdate => 父updated

- 销毁过程

> 父beforeDestroy => 子beforeDestroy => 子destroy => 父destroy

#### delete和Vue.delete删除数组的区别

delete删除的元素会变成empty/undefined，数组长度还是不变的。Vue.delete删除的元素，数组长度会改变是真的删除

#### SPA首屏加载慢如何解决

动态加载；CDN资源服务

#### vue更新视图时触发那些数组方法

push()；
pop()；
shift()；
unshift()；
splice()；
sort()；
reverse()

#### created和mounted的区别

- created：在HTML模板渲染前调用，通常初始化某些属性值，然后再渲染视图
- mounted：再HTML模板渲染完成后，通常再初始化页面完成后，再对HTML的dom进行一些需要的操作

#### vuex有哪几种属性

有五种，State、Getter、Mutation、Action、Module
- state：基本数据(数据源存放地)
- getter：从基本数据派生出的数据
- mutations：提交更改数据的方法，同步！
- action：像一个装饰器，包裹mutations，使其可以异步
- module：模块化vuex

#### vue常用修饰符

**事件修饰符**

- .stop 阻止事件继续传播
- .prevent 阻止标签默认行为
- .capture 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后交由内部元素处理
- .self 只有当event.target是当前元素自身时触发处理函数
- .once 事件只会触发一次
- .passive 告诉浏览器你不想阻止事件的默认行为

**v-model修饰符**

- .lazy 通过这个修饰符，转变为在change事件在触发
- .number 自动将用户输入值转化为数字
- .trim 自动过滤用户输入的收尾空格

**键盘事件修饰符**

- .enter
- .tab
- .delete
- .esc
- .space
- .up
- .down
- .left
- .right

**系统修饰符**

- .ctrl
- .alt
- .shift
- .meta

**鼠标按钮修饰符**

- .left
- .right
- .middle

#### vue事件中如何使用event对象

获取事件对象，方法参数使用$event传递

#### vue 中子组件调用父组件的方法

- 直接在子组件中通过 this.$parent.event 来调用父组件的方法
- 在子组件里用$emit()向父组件触发一个事件，父组件监听这个事件就行了
- 父组件把方法传入子组件中，在子组件里直接调用这个方法

#### 如何获取 dom

> ref="domName" 使用this.$refs.domName

#### Computed和Watch的区别

- computed计算属性：依赖其他属性值，并且computer值有缓存，只有它依赖的属性值发生改变，下次获取computed的值才会发生改变
- watch侦听器：更多是观察的作用，无缓存性，类似某些数据的侦听回调，当监听的数据发生变化时都会执行回调进行后续操作
- 运用场景：
    - 当需要进行数据计算，并且依赖其他数据时应该使用computed，可以利用它的数据缓存性避免每次数据改变都要重新计算
    - 当需要在数据变化时进行异步或者开销较大的操作时应该使用watch，使用watch允许我们执行异步操作，限制我们执行该操作的频率，并在得到最终结果前设置中间值，这些计算属性无法做到
    - 多个因素影响一个属性使用computed，一个因素影响其他多个因素使用watch
- computed和methods的区别
    - computed：计算属性是基于它们的依赖进行缓存的，只有在相关依赖发生改变时才会重新求值
    - methods：调用总会执行

#### 虚拟dom是什么？有什么优缺点？

虚拟dom是一个js对象，模拟的真是dom节点，是真实dom的抽象

- 优点：
    - 保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限
    - 无需手动操作dom：无需手动操纵dom，只需要写好view-model代码逻辑，就能根据虚拟dom和数据双向绑定来更新视图，提高开发效率
    - 跨平台：虚拟dom本质上是JavaScript对象，而dom与平台强相关；相比虚拟dom可以更好的进行跨平台操作，例如服务端渲染、weex开发等
- 缺点：
    - 无法极致优化：在一些性能要求极高的应用中虚拟dom无法进行针对性的性能优化
    - 首次渲染时由于加入了一层dom计算，会比innerHTML插入慢

#### 你都做过哪些 Vue 的性能优化

- 对象层级不要过深，否则性能就会差。
- 不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）
- v-if 和 v-show 区分使用场景
- computed 和 watch 区分场景使用
- v-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if
- 大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格
- 防止内部泄露，组件销毁后把全局变量和时间销毁
- 图片懒加载
- 路由懒加载
- 异步路由
- 第三方插件的按需加载
- 适当采用 keep-alive 缓存组件
- 防抖、节流的运用
- 服务端渲染 SSR or 预渲染

# 性能优化

- 1. 性能优化几个方面
    - 资源压缩合并，减少http请求
    - 非核心代码异步加载
    - 利用浏览器缓存
    - 使用CDN
    - 预解析DNS
- 2. 异步加载
    - 动态脚本加载
    - defer/async
- 3. defer/async加载方式区别
    - 都是异步加载，不会阻塞html渲染，不同是defer会在html渲染完成后再执行脚本，async会在脚本加载完成后立即执行
- 4. 