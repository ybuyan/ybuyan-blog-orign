---
title: 前端面试题2022
display: home
lang: zh
description: 面试题
image: https://picsum.photos/536/354?random&date=2022-03-02
date: 2022-03-02
vssue-title: vuepress-plugin-img-lazy
categories:
  - 面试题
  - 前端
---

# CSS HTML

#### 盒子模型

标准盒子模型(box-sizing: content-box)：margin, border, padding, content  
IE盒子模型(box-sizing: border-box)：margin, content(padding, border, content) 

<!-- more -->

#### CSS常见可继承属性

1. 文字系列: font, font-family, font-size, font-weight, font-style
2. 文本系列: text-indent, text-align, text-shadow, line-height, word-spacing, letter-spacing, text-transform, direction, color,
3. 元素可见性: visibility
4. 表格布局属性: caption-side, border-collapse, empty-cells
5. 列表属性: list-style-type, list-style-image, list-style-position, list-style

#### CSS不能继承的属性

1. display
2. 文本属性: vertical-align, text-decoration
3. 盒子模型属性: 宽度, 高度, 内外边距, 边框
4. 背景属性: 背景图片, 颜色, 位置
5. 定位属性: 浮动, 清除浮动, 定位position
6. a标签的字体颜色不能被继承
7. h1到h6的字体大小也是不能被继承的

#### HTML和HTML5的区别

三个主要区别
1. 文档声明区别
   HTML: 超文本标记语言，纯文本语言  
   HTML5: 文档声明HTML5方便书写 
   ``` html
    <!DOCTYPE html>
   ```
2. 结构语义区别
   HTML5添加了许多语义化标签:  
   ``` html
    <header>
    <nav>
    <section>
    <article>
    <aside>
    <figcaption>
    <figure>
    <footer>
   ```
3. 绘图区别
   HTML: 指可伸缩矢量图形，用于定义网络的基于矢量的图形  
   HTML5: canvas使用脚本在网页上绘制图形，可以控制画布上每一个元素

#### cookie、sessionStorage和localStorage的区别

1. cookie: 本身用户客户端和服务端通信，但是有本地储存的功能，通过document.cookie来获取和修改,如果设置了过期时间，那么在时间到期时会自动消失，如果没有设置过期时间，那么cookie是会话级别的，当会话结束cookie就结束了。  
   cookie缺点: 存储量较小，4kb，会伴随着http的请求头传到服务端
2. localStorage: 生命周期是永久的，除非主动删除，否则不会随着浏览器的关闭而删除。
3. sessionStorage: 临时会话，伴随着浏览器窗口的关闭而删除。当浏览器窗口没有关闭，即使刷新页面或者进入同源窗口，数据也纯在。

#### 常见浏览器内核

Trident: IE(被官方废弃)，只能用于windows，不是开源的  
Gecko: Firefox, 开源，可以跨平台  
Webkit: safari以及低版本Chrome浏览器，开源
Prseto: Opera浏览器  
Blink: 现在的Chrome浏览器

#### W3C标准

对结构: 标签小写，标签闭合，标签不能随意嵌套  
对表现和行为: 建议使用外联CSS和js脚本，实现结构与行为分离，结构与表现分离，主要是为了提高页面渲染速度更快的显示页面。  

#### 如何实现浏览器响应式布局

1. 使用媒体查询@media
2. 使用flex布局
3. 使用rem/百分比/vh/vw单位

#### img的title、alt区别

title: 鼠标移动到图片上显示的文字  
alt: 是图片特有的，当图片加载不出来的时候显示，利于浏览器的SEO检索

#### 表单中的readonly和disabled的区别

相同点: 用户都不能改变表中内容  
不同点: 
1. readonly只作用域input和textarea，disabled可以作用于任何元素
2. readonly可以获取到元素焦点，只是不能修改。disabled设置的文本框无法获取到焦点  
3. 如果表单的字段是disabled，则该字段不会发送或者序列化

# 浏览器

#### 浏览器中输入URL到网页显示，发生了什么

1. DNS域名解析
2. tcp三次握手
3. 建立tcp链接后发送http请求
4. 服务端响应请求，返回请求
5. 浏览器解析HTML，并请求HTML中的资源
6. 浏览器对页面渲染

#### 对BFC规范的理解

BFC(Block formatting context)直译为"块级格式化上下文", 它是一个独立的渲染区域。  
当脱离文档流时会产生:  
1. 根元素，HTML是最大的BFC
2. float的值不为none
3. position的值为absolute或者fixed(sticky不会触发BFC，在计算高度时不会计算float元素)

#### 安全性问题

1. XSS攻击: 注入恶意代码  
   - cookie设置为httpOnly
   - 转义页面输入输出内容
2. CSRF : 跨站请求伪造，防护
   - get 不修改数据
   - 不被第三方网站访问到用户的 cookie
   - 设置白名单，不被第三方网站请求
   - 请求校验

# js部分

#### js变量和函数声明提升

js中用var声明的变量会提升至最顶部执行，即可以在声明变量之前使用该变量。函数声明也会提升，并且函数声明优先与变量声明，匿名函数不会提升。  
由ES6的const和let声明的变量不会提升，所以只能在声明后使用变量，因为此声明会造成暂时性死区，产生块作用域。

#### var、let和const的区别

**var**: ES6之前用来声明变量的关键字。声明的变量会提升到作用域的顶端，所以在没有声明变量之前可以使用变量，会返回undefined。可以被重新声明和修改。 
**let**: ES6之后用来声明变量的关键字。声明的变量在编译时执行，不会变量提升，所以不能在声明之前使用。不能被重新声明，但是可以修改值。let是块级作用域，声明的变量只能在该块中使用。

```js
// var 声明
if(true) {
    var a = 'var声明变量'
}
console.log(a) // var声明变量

// let 声明
if(true) {
    let b = 'let声明变量'
}
console.log(b) // b is not defined
```

**const**: ES6之后用来声明常量的关键字。声明的变量编译时执行，与let一样是块级作用域，不会变量提升，不能重新声明，不能重新赋值，所以必须赋初始值。在对象和数组的声明时，可以更新对象的属性。

#### 闭包

外部函数可以访问内部函数的变量，一个函数作为另一个函数的返回值。  

好处: 保存变量，避免被垃圾回收。可以读取内部函数的变量。
坏处: 耗内存，内存泄漏。

#### this

ECMAScript中这样介绍:
> this 关键字执行为当前执行环境的ThisBinding
MDN这样介绍:
> 在绝大多数情况下，函数的调用方式决定了this的值
可以理解为，在JavaScript中，this的调用时决定的，而不是在创建时决定的，this具有运行时绑定的特性。  
执行期上下文三阶段: 创建，执行，回收。  
this的执行是在创建时被确定的。  

#### map和forEach的区别

forEach基础遍历方法，三个参数，当前项，当前项的索引，以及当前遍历的数组。  
map的用法与forEach一样，不同在它返回一个新的数组，所以必须要由返回值，不然就会返回undefined。  

#### 严格模式限制

- 变量必须声明在使用
- 参数不能有同名属性
- 不能使用with语句
- 禁止this指向全局

#### ES6新增

- 变量声明let、const
- 模板字符串
- 箭头函数、函数可以设置默认参数
- 解构赋值
- 展开符
- 数组方法forEach()、map()、filter()、reduce()、some()、every()
- 对象方法Object.is()比较两个值严格相等，例: Object.is(NaN,NaN)，返回true
- 数组创建，Array.from(), 将类数组或者可迭代对象转为数组
- 新的原始数据类型Symbol，通过Symbol('')创建

#### 什么是单线程，和异步什么关系

单线程: 只有一个线程，只能做一件事。  
在js中，单线程意味着所有的任务需要排队。然后当等待时间过长，就会拖延整个程序的执行。浏览器无响应往往就是因为一个脚本执行时间过长导致的。为了解决这个问题，浏览器将任务分为同步和异步。  
**同步**: 在func返回的时候，得到预期的结果，那么这个函数就是同步的。  
**异步**: 在func返回的时候，得不到预期的结果，而是在将来需要通过一些手段才能得到，那么这个函数就是异步的。  

#### 作用域链

作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此可以通过作用域链访问到父级里面的变量和函数。

#### 什么是原型、原型链、继承

- 原型: 所有的函数都有prototype属性(原型)，所有的对象都有_proto_属性。  
- 原型链: 在JavaScript中，每个函数都有一个原型属性prototype指向自身原型，并且由这个函数作为构造函数而创建的对象会有一个_proto_属性指向这个原型，然而函数的原型是一个对象，所以这个对象有一个_proto_指向自己的原型，直到Object的原型，这样就形成原型链。  
- 继承: 
  - 原型链继承，核心: 将Parent的原型指向Child。缺点: 父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变
  
  ```js
    function Parent() {
        this.name = 'fedaily'
    }

    Parent.prototype.getName = function() {
        return this.name;
    }

    function Child() {}

    // 这里也可以直接写出Child.prototype = Parent.prototype
    // 但是这样就不能访问到父类的构造函数的属性了，即this.name
    Child.prototype = new Parent()

    var child = new Child()
    child.getName() // fedaily
    ```
  - 构造函数继承: 修改父类构造函数的this指向，在子类构造函数中执行父类构造函数，同时修改父类构造函数this为子类的this。 缺点: 所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法

  ```js
    function Parent() {
        this.name = ['fedaily']
    }

    function Child() {
        Parent.call(this)
    }

    var child = new Child()
    child.name.push('fe')

    var child2 = new Child() // child2.name === ['fedaily']
  ```
  - ES6提供了Class语法糖，同时提供了extends实现继承。
  ```js
    class Parent {
        constructor() {
            this.name = 'fedaily'
        }

        getName() {
            return this.name
        }
    }

    class Child extends Parent {
        constructor() {
            // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明
            super()
            this.topic = 'fe'
        }
    }

    const child = new Child()
    child.getName() // fedaily
    ```
#### js的垃圾回收机制是怎样的

- **概述**: js中的垃圾回收机制是为了防止内存泄漏，不停的去寻找不在使用的变量，去释放掉它们所指向的内存，js的执行环境会管理代码执行中的内存。
- **变量的声明周期**: 局部变量，存在与函数中，当函数执行完毕后，该变量内存就被释放。全局变量，当浏览窗口被关闭时内存释放。
- **js垃圾回收方式**: 标记清除，引用计数  
    标记清除: 当变量进入执行环境时，垃圾回收器会将这个变量标记，离开环境时再度标记，然后清除。
    引用计数: 每次引用加一，被释放时减一，当这个值的引用次数变成 0 时，就可以将其内存空间回收

# vue

#### 组件通信
1. props / $emit
2. $children / $parent
3. provide / reject
4. ref
5. eventBus
6. vuex
7. localStroage / sessionStroage
8. $attrs / $listeners

#### <keep-alive></keep-alive>的作用是什么

用于需要频繁切换组件缓存，不需要重新渲染页面。

#### 如何获取dom

给dom元素添加ref='name'，然后通过this.$ref.name来获取dom。

#### 为什么用key

便于diff算法识别节点，使页面渲染加快。

#### 分别减速computed和watch的使用场景

- 所有需要计算的属性都可以用computed，多条数据影响一条数据时用computed
- 一条数据影响多条数据时用watch

#### $nextTick的使用

处理Vue中dom的异步更新。在数据更新后，dom渲染之后自动执行的回调函数。

#### vue组件中的data为什么要以函数的形式

以函数返回值的形式出现，保证在使用组件时生成新的data，这样在复用组件时不会造成混乱，各自维护自己的data。单纯使用对象，那么所有组件实例共同拥有一个data。

#### vue双向数据绑定是如何实现的

核心: vue2使用Object.defineProperty(), vue3中使用代理proxy  
通过数据劫持结合订阅发布来实现，做到数据更新视图，视图更新数据。

#### 父组件和子组件的生命周期加载顺序


